# Java高频面试题

## 1. 自增变量

```java
public static void main(String[] args) {
		int i = 1; //直接赋值操作，把i 存到局部变量表 i = 1
		i = i++;   //因为i++涉及到计算，又因为 i++先入栈后计算,所以先把 i压入到操作数栈，执行i++自					   增操作，把结果2 存放到局部变量表，再执行赋值操作，把操作栈中的i，存放到局				      	 部变量表i的位置  所以 i =1 ,i只是曾经 = 2。
		int j = i++;//如上j = 1,i++后没有给i赋值，局部变量表中的i还是2。
		int k = i + ++i * i++; /*先执行 “=”右边的计算操作，按顺序把变量压如到栈，先是2，然后是 
   								++i,先自增 后入栈，自增后局部变量表i=3,i入栈的是3 ，i++ 先入栈 								后自增，i入栈的是3，然后执行 i++,局部变量表中的 i = 4;此时 操作								   数栈中共有 2+3*3 计算得11,并把结果压缩到操作数栈，再把操作数栈中								的值存放k的局部变量表
    							*/
		System.out.println("i=" + i);   // 4
		System.out.println("j=" + j);   // 1
		System.out.println("k=" + k);   // 11
	}

```

注：此题注意两点 运算时需要先把数据压到操作数栈中，计算的结果赋值给局部变量表,分清操作是栈中是的数据是多少。

* 赋值=，最后计算

* 右边的从左到右加载值依次压入操作数栈

* 实际先算哪个，看运算符优先级

* 自增、自减操作都是直接修改变量的值，不经过操作数栈

* 最后的赋值之前，临时结果也是存储在操作数栈中

## 2. 单例设计模式

单例模式需要满足以下几点

> 1.一个类全局只有一个实例
>
> 2.自己初始化自己
>
> 3.向整个系统提供这个实例



饿汉式：在类加载的时候就创建，不管是否需要。因为类的加载机制，只有一个类加载器去加载这个单例类（双亲委派机制），所以不存在线程安全问题。

```java
//-------------------------------类加载初始化-------------------------------
public class Singleton() {
    Singleton（）{}；//构造方法私有化
    public static final Singleton singleton = new Singleton();
    //直接公开静态方法向外提供对象，静态方法可通过类直接调用。    
}
```

懒汉式：使用的时候创建，延时创建。如果在多线程环境需要解决 线程安全和线程效率的问题

```java
//-------------------------------双重检索-------------------------------

public class Singleton() {
    private Singleton(){} //1.构造方法私有
    
    private static Singleton singleton = null;  //2.使用一个静态变量存储实例化好的对象
    
    public static getInstance() {     //3.写静态方法对外提供单例对象的获取
        
        if(singleton == null) {  //6.因为synchronized是比较重的锁，会引起线程长时间阻塞，所以先加									一层判断，如果对象不为空才进行以下操作。
                synchronized（Singleton.class）{ //5.这时需要同步操作，synchronized的原理就是如果一个线程需要进入synchronized代码块，需要持有判断对象的锁，因为代码块中操作的是 类的实例化，所以以类为标志，一个线程只有得到Singleton类的锁才能进入到实例化操作，否则被阻塞，其他线程只能等当前线程释放锁才能继续进入，如果进入以后判断类的实例不为空，则不需要初始化操作。

                    if (singleton == null) {	  //4.判断对象是否存在，不存在new一个对象，这													   时如果跳过了!=null 判断，还没有new对														象，恰巧另一个线程也跳过了判断，这时候两个												线程会分别new一个对象，一个类会出现多个实例。
                        singleton = new Singleton();
                    }
                }
            }
        }
      
}
```

```java
//-------------------------------内部静态类-------------------------------

public class Singleton() {
    private Singleton(){} //1.构造方法私有
    
    private static class Inner() { //静态类内部，静态类内部不会随外部类的加载而加载，在											调用的时候才由类加载器加载，所以延时创建而且线程安全。
        private static final Singleton SINGLETON = new Singleton();
    }
    public static getInstence() {
        Inner.SINGLETON();
    }
    
}
```

## 3. 类的初始化和实例初始化等

![](https://readingnotes.oss-cn-beijing.aliyuncs.com/Java%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/Father%26Son.jpg)



考点：

### 3.1 类的初始化过程。

1. 一个类要创建实例需要先加载并初始化该类。
   * main方法所在的类要先加载并初始化。如果main方法在子类，要先加载子类并初始化。
2. 一个子类要初始化需要先初始化父类。
3. 一个类的初始化就是执行<clint>方法
   * <clint>方法由静态类变量显式赋值代码和静态代码块组成。
   * 静态类变量显式赋值和静态代码块代码从上到下依次执行。
   * <clint>(）方法只执行一次。

> 由上面得出先要加载Son类先要初始化Father类，初始化Father类需要先要执行静态类变量显式的赋值代码
>
> （j = method()  ） 调用 method()  方法，输出 (5) ,然后再执行Father类的静态代码块 输出 (1)；执行完Father的初始化再执行Son的初始化，过程一样，则输出 （10），（6）；



### 3.2 实例的初始化过程。

实例初始化就是执行<init>方法。

1. <init>()方法可能重载有多个，有几个构造器就有几个<init>方法
2. <init>()方法由非静态实例变量显示赋值代码和非静态代码块、对应构造器代码组成
3. 非静态实例变量显示赋值代码和非静态代码块代码从上到下顺序执行，而对应构造器的代码最后执行
4. 每次创建实例对象，调用对应构造器，执行的就是对应的<init>方法
5. <init>方法的首行是super()或super(实参列表)，即对应父类的<init>方法。



**Son类的实例化方法**

> Son son1 = new Son();
>
> 由上面结论得出。
>
> 1. Son的初始化的第一行肯定是  super();         	*执行父类的初始化*，如下
>
> 2. 执行Son的非静态变量的显示赋值
> 3. 非静态代码块
> 4. 然后的无参构造

**Father类的实例化方法**

> Super();		*因为Father的父类为Object对象，不能被初始化。*
>
> 执行Father的非静态变量的显示赋值            *执行的是 i = test() ，理论上调用的是Father的test方法，但实际*						     
>
> 									 *调用的是子类的test()方法，详见 3.3 第2点* 
>
> 非静态代码块
>
> 然后的无参构造



由上过程所以输出的结果为：Father（9）（3）（2），Son （9）（8）（7）

因为执行了两次 Son 初始化 ，最终结果 （5）（1）（10）（6）（9）（3）（2）（9）（8）（7）（9）（3）（2）（9）（8）（7）



### 3.3 方法重写。

①哪些方法不可以被重写

* final方法
* 静态方法				**所以类加载时候父类的method执行的是自己的方法**	

* private等子类中不可见方法

②对象的多态性

* 子类如果重写了父类的方法，通过子类对象调用的一定是子类重写过的代码

* 非静态方法默认的调用对象是this

* this对象在构造器或者说<init>方法中就是正在创建的对象



















